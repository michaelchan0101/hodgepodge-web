# V8 GC

## 可能会造成内存泄漏的情况
- 全局变量
- 闭包
- 事件监听

## 回收机制

### 标记清除
- 如果能从 root 的引用链到达访问，V8 就会将其标记为**可到达对象**，反之为**不可到达对象**
- 当变量进入环境（被声明）时，标记为“进入环境”。当其离开时，标记为“离开环境”
- 垃圾收集器在运行的时候给存储中所有的变量都加上标记
- 去掉运行环境中的变量已经被环境中变量所引用的变量的标记（去掉正在活动变量的标记）
- 剩下有标记的变量就被视为准备要删除的，因为在运行环境已经无法访问到
- 完成清除工作，销毁带标记的变量并回收所占用的空间
- 目前各大浏览器主流的回收机制

### 引数清除
- 当声明一个变量并将一个引用类型赋值给该变量时，引用次数 +1
- 如果这个值引用变量改变了，该引用对象就 -1
- 如果出现循环引用，则无法回收

## V8 垃圾回收策略
- 分为新生代和老生代
- 新生代在32位操作系统的内存大小为 16M ，64位操作系统的大小为 32M
- 老生代在32位操作系统的内存大小为 700M ，64位操作系统的大小为 1.4G

### 新生代
- 把内存平分为两块同样大小的空间（ `from`, `to` ）
- 存的都是生命周期短的对象，只保存对象的指针
- 在存储空间快要满的时候，进行一次垃圾回收
- 采用了 `Scavenge` 垃圾回收算法，这算法又主要采用了 `Cheney` 算法
  - 遍历 `from` 空间
  - 判断当前对象是否活跃，有没有其它引用
  - 判断当前对象是否被复制过（是否经历过一次垃圾回收），如果是，则晋升到老生代
  - 判断 `to` 空间是否已经使用了25%，如果是，则晋升到老生代
  - 把当前对象复制到 `to` 空间
  - 结束遍历，交换空间。`to` 切换成 `from` ， `from` 切换成 `to`。

### 老生代
- 采用 `Mark-Sweep` 和 `Mark-Compact` 结合的方式进行垃圾回收
- 不采用 `Scavenge` 算法的原因
  - 存活对象多的时候，复制的效率很低
  - 会浪费一半的内存
- `Mark-Sweep` 标记清除，走清除流程。清除完成，会出现一些碎片化的空间。
  - [a, b, c , d, e, d]， 删除 b, d, e
  - [a, , c, , , d]
- `Mark-Compact` 当新对象进来，已经没有一个碎片空间可以满足其大小的时候，就会整理和移动其活动对象。
  - [a, , c, , , d]
  - [a, c, d,,,]

## Incremental Marking(增量标记)
- 由于垃圾回收过程会把应用逻辑停顿下来（阻塞主线程），所以把一次性标记改成增量标记
  - 分块标记，标记一部分的对象，然后暂停，把执行权交给主线程。类似 React Fiber 架构
- 后续引入了延迟清理（lazy sweeping），增量式整理（incremental compaction）
  - 让清理和整理都编程增量式的
  - 利用多核 CPU 性能，引入并行标记和并行清理